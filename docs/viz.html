<!DOCTYPE html>
<meta charset="utf-8">

<body>
<script src="https://d3js.org/d3.v3.min.js"></script>
<link rel="stylesheet" href="./_css/style.css"></link>
<h2>Steve and Monicah's Parallel Coordinate Chart</h2>
<h3>Times Higher Education World University Rankings (2011-2016 - top 200 only)</h3>
<script>

/*The functionality of this chart is derived from projects availble on bl.ocks.org.
Combining each of these pieces was somewhat complicated due to differences in
the individual design of each project.
The basic parallel coordinates chart, with brushing and axis dragging:
https://bl.ocks.org/mbostock/7586334 Mike Bostock
Line highlighting and tooltip:
http://bl.ocks.org/ABSegler/9791707  - AB Segler
Ordinal axis brushing:
http://bl.ocks.org/chrisbrich/4173826 - Chris Rich
Coloring and legend:
https://bl.ocks.org/YuanyuanZh/28897524626fa3f1d4c0 - Yuanyuan Zhang */

//definition of our workspace size
var margin = [50, 10, 10, 100],
    width = 1024 - margin[1] - margin[3],
    height = 600 - margin[0] - margin[2],
    height2 = height - 30;

//definitions to store what is being dragged
var x = d3.scale.ordinal().rangePoints([0, width], 1),
    y = {},
    dragging = {};

//chart elements
var line = d3.svg.line(),
    axis = d3.svg.axis().orient("left"),
    background,
    foreground;

//our tooltip definition
var tooltip = d3.select("body")
    .append("div")
    .style("position", "absolute")
    .style("z-index", "10")
    .style("visibility", "hidden")
    .text("a simple tooltip")
    .attr("class","tooltip");

//creating the workspace for our chart
var svg = d3.select("body").append("svg")
    .attr("width", width + margin[1] + margin[3])
    .attr("height", height + margin[0] + margin[2])
    .append("g")
    .attr("transform", "translate(" + margin[3] + "," + margin[0] + ")");

//colors of the chart lines by region
var color = { "Europe":"#54AF52",  "North America": "#DD6CA7", "Oceania": "#ff9f2f", "Africa": "#9D5130", 
              "Middle East":"#AB9C27", "South America": "#D58323", "Asia": "#5DA5B3"};

//defining which country belongs to which region (could be done better using a data file)
var group = { "Australia": "Oceania",
              "Austria": "Europe",
              "Belgium": "Europe",
              "Brazil": "South America",
              "Canada": "North America",
              "China": "Asia",
              "Denmark": "Europe",
              "Egypt": "Middle East",
              "Finland": "Europe",
              "France": "Europe",
              "Germany": "Europe",
              "Hong Kong": "Asia",
              "Israel": "Middle East",
              "Italy": "Europe",
              "Japan": "Asia",
              "Luxembourg": "Europe",
              "Netherlands": "Europe",
              "New Zealand": "Oceania",
              "Norway": "Europe",
              "Republic of Ireland": "Europe",
              "Russian Federation": "Europe",
              "Singapore": "Asia",
              "South Africa": "Africa",
              "South Korea": "Asia",
              "Spain": "Europe",
              "Sweden": "Europe",
              "Switzerland": "Europe",
              "Taiwan": "Asia",
              "Turkey": "Middle East",
              "United Kingdom": "Europe",
              "United States of America": "North America"
            };

//reading in the data for the school rankings
d3.csv("./_data/timesData3.csv", function(error, data) {
  //if (error) throw error;
  // Extract the list of dimensions and create a scale for each.
  x.domain(dimensions = d3.keys(data[0]).filter(function(d) {
    //ordinal scale for our country list
    if (d == "country") { return y[d] = d3.scale.ordinal()
        .domain(data.map( function(p) { return p[d]; }).sort())
        .rangePoints([0, height2]);}
    //reverse the scale for our rankings (low numbers on top)
    if (d == "world_rank") { return y[d] = d3.scale.linear()
        .domain(d3.extent(data, function(p) { return +p[d]; }))
        .range([0, height2]);}

    //the rest of these are the same - maybe refactor into a function later
    if (d == "teaching") { return y[d] = d3.scale.linear()
        .domain(d3.extent(data, function(p) { return +p[d]; }))
        .range([height2, 0]);}

    if (d == "international_students") {return y[d] = d3.scale.linear()
        .domain(d3.extent(data, function(p) { return +p[d]; }))
        .range([height2, 0]);}

    if (d == "research") {return y[d] = d3.scale.linear()
        .domain(d3.extent(data, function(p) { return +p[d]; }))
        .range([height2, 0]);}

    if (d == "citations") {return y[d] = d3.scale.linear()
        .domain(d3.extent(data, function(p) { return +p[d]; }))
        .range([height2, 0]);}

    if (d == "income") { return y[d] = d3.scale.linear()
        .domain(d3.extent(data, function(p) { return +p[d]; }))
        .range([height2, 0]);}

    return false;
  }));
    
  // Add grey background lines for context.
  background = svg.append("g")
      .attr("class", "background")
      .selectAll("path")
      .data(data)
      .enter().append("path")
      .attr("d", path);

  //Foreground lines will appear when selected data is brushed
  //if a mouse is over a line, it will display a tooltip
  foreground = svg.append("g")
    .attr("class", "foreground")
    .selectAll("path")
    .data(data)
    .enter().append("path")
    .attr("d", path)
    //mouse over functions
    .on("mouseover", mouseover)
    .on("mousemove", function(){
        return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");})
    .on("mouseout", mouseout)
    //determine the color by looking up the regional group of a country and then its color
    .attr({'style': function(d) {
          return "stroke: " + color[group[d.country]];
     }});
    
  // this is the functionality for axis dragging
  var g = svg.selectAll(".dimension")
      .data(dimensions)
      .enter().append("g")
      .attr("class", "dimension")
      .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
      .call(d3.behavior.drag()
        .on("dragstart", function(d) {
          dragging[d] = this.__origin__ = x(d);
          background.attr("visibility", "hidden");
        })
        .on("drag", function(d) {
          dragging[d] = Math.min(width, Math.max(0, this.__origin__ += d3.event.dx));
          foreground.attr("d", path);
          dimensions.sort(function(a, b) { return position(a) - position(b); });
          x.domain(dimensions);
          g.attr("transform", function(d) { return "translate(" + position(d) + ")"; })
        })
        .on("dragend", function(d) {
          delete this.__origin__;
          delete dragging[d];
          transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
          transition(foreground)
              .attr("d", path);
          background
              .attr("d", path)
              .transition()
              .delay(500)
              .duration(0)
              .attr("visibility", null);
        }));

  // Add an axis and title.
  g.append("g")
      .attr("class", "axis")
      .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
      .append("text")
      .attr("text-anchor", "middle")
      .attr("y", -9)
      .text(String);

  // Add and store a brush for each axis.
  g.append("g")
      .attr("class", "brush")
      .each(function(d) { 
            d3.select(this)
                .call(y[d].brush = d3.svg.brush().y(y[d])
                .on("brushstart", brushstart)
                .on("brush", brush)); })
      .selectAll("rect")
      .attr("x", -8)
      .attr("width", 16);
    
  //create the legend
  var legend = svg.append('g')
      .attr("width", 60)
      .attr("height", 10)
      .attr('stroke', '#555')
      .attr("transform", "translate("+100+", "+ height + ")");
  //function to draw the legend elements
  var newLegend = function(legendContainer, color, text, offsetX) {
    var g = legendContainer.append('g');
    if (offsetX) {
        g.attr("transform", "translate(" + offsetX + ", 0)");
    }
    g.append('text')
      .style({'font-size': '8px', 'stroke': color, 'fill': color})
      .text('██');
    g.append('text')
      .attr("transform", "translate(20, 0)")
      .attr('fill', '#000')
      .text(text);
  };
  //loops through each color group and calls a legend element to be drawn
  var value;
  var i = 0;
 //http://stackoverflow.com/questions/33946567/javascript-iterate-over-values-of-map
  Object.keys(color).forEach(function(key) {
      value = color[key];
      newLegend(legend, value, key, i*100);
      i++;
  });
});

//on mouseover of a line, highlight the selected line and display a tooltip
function mouseover(d) {
    svg.classed("active", true);
    foreground.classed("inactive", function(p) { return p !== d; });
    foreground.classed("highlight", function(p) { return p === d; });
    foreground.filter(function(p) { return p === d; }).each(moveToFront);
    tooltip.text("#"+d.world_rank+": "+d.university_name+" ("+d.year+")");
    return tooltip.style("visibility", "visible");
}

//when a mouse is not over a line, display all lines normally
//and hide the tooltip
function mouseout(d) {      
    svg.classed("active", false);
    foreground.classed("inactive", false);
    foreground.classed("highlight", false);
    return tooltip.style("visibility", "hidden");
}

//also, make sure the highlighted line is displayed on top of
//all the other lines
function moveToFront() {
    this.parentNode.appendChild(this);
}
    
//used to get position of dragged axes    
function position(d) {
  var v = dragging[d];
  return v == null ? x(d) : v;
}

//animation for the dragging of axes
function transition(g) {
  return g.transition().duration(500);
}

// Returns the path for a given data point.
function path(d) {
  return line(dimensions.map(function(p) { return [position(p), y[p](d[p])]; }));
}

// When brushing, don’t trigger axis dragging.
function brushstart() {
  d3.event.sourceEvent.stopPropagation();
}

// Handles a brush event, toggling the display of foreground lines.
//this part is tricky as you need to convert the ordinal axes to pixel range
function brush() {
  var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
      extents = actives.map(function(p) { 
              return y[p].brush.extent();
      });
  foreground.style("display", function(d) {
    return actives.every(function(p, i) {
        var p_new = (y[p].ticks)?d[p]:y[p](d[p]); //convert to pixel range if ordinal
          return extents[i][0] <= p_new && p_new <= extents[i][1];
    }) ? null : "none";
  });
}

</script>
<br>
The functionality of this chart is derived from projects available on bl.ocks.org:<br>
The basic parallel coordinates chart, with brushing and axis dragging:
<a href="https://bl.ocks.org/mbostock/7586334">Mike Bostock</a><br>
Line highlighting and tooltip:
<a href="http://bl.ocks.org/ABSegler/9791707">AB Segler</a><br>
Ordinal axis brushing:
<a href="http://bl.ocks.org/chrisbrich/4173826">Chris Rich</a><br>
Coloring and legend:
<a href="https://bl.ocks.org/YuanyuanZh/28897524626fa3f1d4c0">Yuanyuan Zhang</a><br>
</body>